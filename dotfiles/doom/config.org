#+title: Literate Doom Emacs Configuration
#+PROPERTY: header-args:elisp :tangle config.el

* Initial Setup
** Testing
This will test our emacs load time and setup. Comment out when not in use!
#+begin_src elisp
;; Profile startup
;; (add-hook 'emacs-startup-hook
;;           (lambda ()
;;             (message "*** Emacs loaded in %s with %d garbage collections."
;;                      (format "%.2f seconds"
;;                              (float-time
;;                               (time-subtract after-init-time before-init-time)))
;;                      gcs-done)))

;; ;; For detailed profiling, temporarily add:
;; (setq use-package-verbose t)

;; Seeing cost of startup modules - Debug mode
;; (setq doom-debug-p t)
#+end_src
** Startup Optimizations
#+begin_src elisp
;; Maximum GC threshold during startup - prevent collections entirely
(setq gc-cons-threshold most-positive-fixnum
      gc-cons-percentage 1.0)

;; Restore GC after startup with idle-timer for smoother operation
(add-hook 'emacs-startup-hook
          (lambda ()
            (setq gc-cons-threshold (* 256 1024 1024)  ; 256MB
                  gc-cons-percentage 0.1)
            ;; GC when truly idle (5 seconds of no input)
            (run-with-idle-timer 5 t
              (lambda ()
                (when (not (active-minibuffer-window))
                  (garbage-collect))))))

;; Reduce startup noise
(setq inhibit-compacting-font-caches t
      inhibit-startup-screen t
      initial-scratch-message nil
      frame-inhibit-implied-resize t)  ; Critical for X11

;; Make EVERY package defer by default
(setq use-package-always-defer t
      use-package-expand-minimally t)  ; Faster macro expansion

(setq doom-incremental-idle-timer 10.0)  ; Increase from default 1.0
(setq doom-incremental-first-idle-timer 5.0)  ; Increase from default 0.5
#+end_src

** Included configuration
#+begin_src elisp
;;; $DOOMDIR/config.el -*- lexical-binding: t; -*-

;; Place your private configuration here! Remember, you do not need to run 'doom
;; sync' after modifying this file!

;; Some functionality uses this to identify you, e.g. GPG configuration, email
;; clients, file templates and snippets.
;; Personal info from pass (keeps secrets private)
(setq user-full-name
      (string-trim
       (shell-command-to-string "pass show personal/fullname"))
      user-mail-address
      (string-trim
       (shell-command-to-string "pass show personal/email")))
(setq auth-sources '("~/.authinfo.gpg" "~/.authinfo")
      auth-source-cache-expiry nil) ; default is 7200 (2h)
#+end_src

** Keychain setup
Using ssh keys for various servers/repos, easiest way to keep this persistent.

#+BEGIN_SRC elisp
;; Set SSH_AUTH_SOCK from keychain
(setenv "SSH_AUTH_SOCK" 
        (concat (or (getenv "XDG_RUNTIME_DIR") 
                    (format "/run/user/%d" (user-uid)))
                "/gnupg/S.gpg-agent.ssh"))
#+END_SRC
** EPA (EasyPG) - Automated GPG Handling
Configure Emacs to handle GPG encryption/decryption automatically using passphrase from pass.
This eliminates password prompts when accessing .authinfo.gpg and other encrypted files.

#+begin_src elisp
;; EPA/EPG configuration for automatic GPG handling
(use-package! epa-file
  :config
  ;; Use loopback pinentry mode so Emacs can handle passphrases
  (setq epa-pinentry-mode 'loopback
        ;; Cache passphrases to avoid repeated prompts
        epa-file-cache-passphrase-for-symmetric-encryption t
        epa-file-select-keys nil  ; Don't prompt for key selection
        ;; Suppress unnecessary warnings
        epa-file-encrypt-to nil))

(use-package! epg
  :config
  (setq epg-pinentry-mode 'loopback
        ;; Use your default GPG key
        epg-user-id "0x09D801B2351193B1"))

;; Function to preset GPG passphrase from pass
(defun my/preset-gpg-passphrase ()
  "Preset GPG passphrase from pass into gpg-agent cache."
  (interactive)
  (let* ((passphrase (string-trim (shell-command-to-string "pass show gpg/passphrase")))
         ;; Use the encryption subkey keygrip
         (keygrip "7D56E57856F538345B12F1541961488699871CA2"))
    (when (and passphrase (not (string-empty-p passphrase)))
      (shell-command 
       (format "echo %s | /run/current-system/sw/bin/gpg-preset-passphrase --preset %s" 
               (shell-quote-argument passphrase) 
               keygrip))
      (message "GPG passphrase cached successfully"))))

;; Automatically preset passphrase on Emacs startup
(add-hook 'emacs-startup-hook #'my/preset-gpg-passphrase)

;; Optional: Add a keybinding to manually refresh the passphrase cache
(map! :leader
      :desc "Refresh GPG passphrase cache" "o g" #'my/preset-gpg-passphrase)
#+end_src

** Fonts
I really like GeistMono as a replacement for SourceCode Pro. Alegreya is a great writing font

#+begin_src elisp
;; Doom exposes five (optional) variables for controlling fonts in Doom. Here
;; are the three important ones:
(setq doom-font (font-spec :family "GeistMono Nerd Font" :size 15)
      doom-variable-pitch-font (font-spec :family "Alegreya" :size 18)
      doom-big-font (font-spec :family "GeistMono Nerd Font" :size 22))
;;   presentations or streaming.
;;
;; They all accept either a font-spec, font string ("Input Mono-12"), or xlfd
;; font string. You generally only need these two:
;; (setq doom-font (font-spec :family "monospace" :size 12 :weight 'semi-light)
;;       doom-variable-pitch-font (font-spec :family "sans" :size 13))
#+end_src

** Theming
I like the nord theme that is packaged with doom, though I have done some customization in the past, which live in the themes directory. I also don't want a top bar, as I launch and close emacs with the keyboard, and it looks bad.

#+begin_src elisp
;; There are two ways to load a theme. Both assume the theme is installed and
;; available. You can either set `doom-theme' or manually load a theme with the
;; `load-theme' function. This is the default:
(add-to-list 'custom-theme-load-path "~/.config/doom/themes/")
(load-theme 'compline t)

;; Maintain terminal transparency in Doom Emacs
(after! doom-themes
  (unless (display-graphic-p)
    (set-face-background 'default "undefined")))

;; remove top frame bar in emacs
(add-to-list 'default-frame-alist '(undecorated . t))
#+end_src

*** Modeline setup
#+begin_src elisp
(setq doom-modeline-icon t)
(setq doom-modeline-major-mode-icon t)
(setq doom-modeline-lsp-icon t)
(setq doom-modeline-major-mode-color-icon t)
#+end_src

** Transparency
#+begin_src elisp
;; Transparency
(set-frame-parameter (selected-frame) 'alpha '(96 . 97))
(add-to-list 'default-frame-alist '(alpha . (96 . 97)))
#+end_src

** Indenting
#+begin_src elisp
;; Aggresssive Indent
;; (use-package! aggressive-indent
;;   :defer t
;;   :hook (prog-mode . aggressive-indent-mode))
#+end_src

** Cursor blink
#+begin_src elisp
;; Blink cursor
(blink-cursor-mode 1)
#+end_src

** Line wrapping and tweaks
We set the visual line wrapping and relative line numbers (then we can just go up or down by X number of lines)

#+begin_src elisp
;; This determines the style of line numbers in effect. If set to `nil', line
;; numbers are disabled. For relative line numbers, set this to `relative'.
(setq display-line-numbers-type 'relative)

;; Line wrapping
(global-visual-line-mode t)
#+end_src

** Setup trash and auto saving
#+begin_src elisp
;; Send files to trash instead of fully deleting
(setq delete-by-moving-to-trash t)
;; Save automatically
(setq auto-save-default t)
#+end_src

** Optimizations
#+begin_src elisp
;; Performance optimizations
(setq gc-cons-threshold (* 256 1024 1024))
(setq read-process-output-max (* 4 1024 1024))
(setq comp-deferred-compilation t)
(setq comp-async-jobs-number 8)

;; Garbage collector optimization
(setq gcmh-idle-delay 5)
(setq gcmh-high-cons-threshold (* 1024 1024 1024))

;; Version control optimization
(setq vc-handled-backends '(Git))

;; Fix x11 issues
(setq x-no-window-manager t)
(setq frame-inhibit-implied-resize t)
(setq focus-follows-mouse nil)
#+end_src

** Splash Screen
#+begin_src elisp
(remove-hook '+doom-dashboard-functions #'doom-dashboard-widget-shortmenu)
(remove-hook '+doom-dashboard-functions #'doom-dashboard-widget-footer)

;; Your splash image
(setq fancy-splash-image 
      (expand-file-name "~/nixos-config/wallpapers/michaelemacs.jpg"))
;; Custom footer with Jerusalem cross
(defun +my/dashboard-footer ()
  (insert "\n\n")
  (let ((start (point)))
    (insert (+doom-dashboard--center
             +doom-dashboard--width
             (or (nerd-icons-mdicon "nf-md-cross"
                                   :face `(:foreground "#ffffff"
                                          :height 1.3
                                          :v-adjust -0.15))
                 (propertize "✠" 
                            'face '(:height 1.3 
                                   :v-adjust -0.15
                                   :inherit doom-dashboard-footer-icon)))))
    (make-text-button start (point)
                      'action (lambda (_) (browse-url "https://thephatle.dev"))
                      'follow-link t
                      'help-echo "Visit thephatle.dev"
                      'face 'doom-dashboard-footer-icon
                      'mouse-face 'highlight))
  (insert "\n"))

;; Hook everything in order
(add-hook! '+doom-dashboard-functions :append
  #'+my/dashboard-footer
  (insert "\n" (+doom-dashboard--center +doom-dashboard--width "Welcome Home, Phat Le.")))
#+end_src

** Notes and misc
#+begin_src elisp
;; Here are some additional functions/macros that could help you configure Doom:
;;
;; - `load!' for loading external *.el files relative to this one
;; - `use-package!' for configuring packages
;; - `after!' for running code after a package has loaded
;; - `add-load-path!' for adding directories to the `load-path', relative to
;;   this file. Emacs searches the `load-path' when you load packages with
;;   `require' or `use-package'.
;; - `map!' for binding new keys
                                        ;(require 'org-mime)
#+end_src

** Set Firefox Browser as default
#+begin_src elisp
;; set specific browser to open links
;;(setq browse-url-browser-function 'browse-url-firefox)
;; set browser to firefox
(setq browse-url-browser-function 'browse-url-firefox)
(setq browse-url-generic-program "firefox")  ; replace with actual executable name
#+end_src

** Whichkey speedup
#+begin_src elisp
;; Speed of which-key popup
(setq which-key-idle-delay 0.2)
#+end_src

** Completion
#+begin_src elisp
;; Completion mechanisms (commented out as they interfere with vertico)
;; (setq completing-read-function #'completing-read-default)
;; (setq read-file-name-function #'read-file-name-default)
;; Makes path completion more like find-file everywhere
(setq read-file-name-completion-ignore-case t
      read-buffer-completion-ignore-case t
      completion-ignore-case t)
;; Use the familiar C-x C-f interface for directory completion
(map! :map minibuffer-mode-map
      :when (modulep! :completion vertico)
      "C-x C-f" #'find-file)

;; Save minibuffer history - enables command history in M-x
(use-package! savehist
  :config
  (setq savehist-file (concat doom-cache-dir "savehist")
        savehist-save-minibuffer-history t
        history-length 1000
        history-delete-duplicates t
        savehist-additional-variables '(search-ring
                                        regexp-search-ring
                                        extended-command-history))
  (savehist-mode 1))

(after! vertico
  ;; Add file preview
  (add-hook 'rfn-eshadow-update-overlay-hook #'vertico-directory-tidy)
  (define-key vertico-map (kbd "DEL") #'vertico-directory-delete-char)
  (define-key vertico-map (kbd "M-DEL") #'vertico-directory-delete-word)
  ;; Make vertico use a more minimal display
  (setq vertico-count 17
        vertico-cycle t
        vertico-resize t)
  ;; Enable alternative filter methods
  (setq vertico-sort-function #'vertico-sort-history-alpha)
  ;; Quick actions keybindings
  (define-key vertico-map (kbd "C-j") #'vertico-next)
  (define-key vertico-map (kbd "C-k") #'vertico-previous)
  (define-key vertico-map (kbd "M-RET") #'vertico-exit-input)

  ;; History navigation
  (define-key vertico-map (kbd "M-p") #'vertico-previous-history)
  (define-key vertico-map (kbd "M-n") #'vertico-next-history)
  (define-key vertico-map (kbd "C-r") #'consult-history)

  ;; Configure orderless for better filtering
  (setq completion-styles '(orderless basic)
        completion-category-defaults nil
        completion-category-overrides '((file (styles basic partial-completion orderless))))

  ;; Customize orderless behavior
  (setq orderless-component-separator #'orderless-escapable-split-on-space
        orderless-matching-styles '(orderless-literal
                                    orderless-prefixes
                                    orderless-initialism
                                    orderless-flex
                                    orderless-regexp)))

;; Quick command repetition
(use-package! vertico-repeat
  :after vertico
  :config
  (add-hook 'minibuffer-setup-hook #'vertico-repeat-save)
  (map! :leader
        (:prefix "r"
         :desc "Repeat completion" "v" #'vertico-repeat)))

;; TODO Not currently working
;; Enhanced sorting and filtering with prescient
;; (use-package! vertico-prescient
;;   :after vertico
;;   :config
;;   (vertico-prescient-mode 1)
;;   (prescient-persist-mode 1)
;;   (setq prescient-sort-length-enable nil
;;         prescient-filter-method '(literal regexp initialism fuzzy)))

;; Enhanced marginalia annotations
(after! marginalia
  (setq marginalia-annotators '(marginalia-annotators-heavy marginalia-annotators-light nil))
  ;; Show more details in marginalia
  (setq marginalia-max-relative-age 0
        marginalia-align 'right))

;; Corrected Embark configuration
(map! :leader
      (:prefix ("k" . "embark")  ;; Using 'k' prefix instead of 'e' which conflicts with elfeed
       :desc "Embark act" "a" #'embark-act
       :desc "Embark dwim" "d" #'embark-dwim
       :desc "Embark collect" "c" #'embark-collect))

;; Configure consult for better previews
(after! consult
  (setq consult-preview-key "M-."
        consult-ripgrep-args "rg --null --line-buffered --color=never --max-columns=1000 --path-separator /   --smart-case --no-heading --with-filename --line-number --search-zip"
        consult-narrow-key "<"
        consult-line-numbers-widen t
        consult-async-min-input 2
        consult-async-refresh-delay 0.15
        consult-async-input-throttle 0.2
        consult-async-input-debounce 0.1)

  ;; More useful previews for different commands
  (consult-customize
   consult-theme consult-ripgrep consult-git-grep consult-grep
   consult-bookmark consult-recent-file consult-xref
   :preview-key '(:debounce 0.4 any)))

;; Enhanced directory navigation
(use-package! consult-dir
  :bind
  (("C-x C-d" . consult-dir)
   :map vertico-map
   ("C-x C-d" . consult-dir)
   ("C-x C-j" . consult-dir-jump-file)))

;; Add additional useful shortcuts
(map! :leader
      (:prefix "s"
       :desc "Command history" "h" #'consult-history
       :desc "Recent directories" "d" #'consult-dir))
#+end_src

** Company
#+begin_src elisp
(after! company
  (setq company-minimum-prefix-length 2
        company-idle-delay 0.2
        company-show-quick-access t
        company-tooltip-limit 20
        company-tooltip-align-annotations t)

  ;; Make company-files a higher priority backend
  (setq company-backends (cons 'company-files (delete 'company-files company-backends)))

  ;; Better file path completion settings
  (setq company-files-exclusions nil)
  (setq company-files-chop-trailing-slash t)

  ;; Enable completion at point for file paths
  (defun my/enable-path-completion ()
    "Enable file path completion using company."
    (setq-local company-backends
                (cons 'company-files company-backends)))

  ;; Enable for all major modes
  (add-hook 'after-change-major-mode-hook #'my/enable-path-completion)

  ;; Custom file path trigger
  (defun my/looks-like-path-p (input)
    "Check if INPUT looks like a file path."
    (or (string-match-p "^/" input)         ;; Absolute path
        (string-match-p "^~/" input)        ;; Home directory
        (string-match-p "^\\.\\{1,2\\}/" input))) ;; Relative path

  (defun my/company-path-trigger (command &optional arg &rest ignored)
    "Company backend that triggers file completion for path-like input."
    (interactive (list 'interactive))
    (cl-case command
      (interactive (company-begin-backend 'company-files))
      (prefix (when (my/looks-like-path-p (or (company-grab-line "\\([^ ]*\\)" 1) ""))
                (company-files 'prefix)))
      (t (apply 'company-files command arg ignored))))

  ;; Add the custom path trigger to backends
  (add-to-list 'company-backends 'my/company-path-trigger))
#+end_src

* Org mode setup
** Initial setup
#+begin_src elisp
;; If you use `org' and don't want your org files in the default location below,
;; change `org-directory'. It must be set before org loads!
(setq org-directory "~/org")

(use-package org
  :defer t 
  :custom (org-modules '(org-habit)))

(after! org
  (map! :map org-mode-map
        :n "<M-left>" #'org-do-promote
        :n "<M-right>" #'org-do-demote)
  )

;; Auto-clock in when state changes to STRT
(defun my/org-clock-in-if-starting ()
  "Clock in when the task state changes to STRT"
  (when (and (string= org-state "STRT")
             (not (org-clock-is-active)))
    (org-clock-in)))

;; Auto-clock out when leaving STRT state
(defun my/org-clock-out-if-not-starting ()
  "Clock out when leaving STRT state"
  (when (and (org-clock-is-active)
             (not (string= org-state "STRT")))
    (org-clock-out)))

;; Add these functions to org-after-todo-state-change-hook
(add-hook 'org-after-todo-state-change-hook 'my/org-clock-in-if-starting)
(add-hook 'org-after-todo-state-change-hook 'my/org-clock-out-if-not-starting)

;; (after! org
;;   (use-package! org-fancy-priorities
;;     :hook
;;     (org-mode . org-fancy-priorities-mode)
;;     :config
;;     (setq org-fancy-priorities-list '("HIGH" "MID" "LOW" "FUTURE"))))

;; Prevent clock from stopping when marking subtasks as done
(setq org-clock-out-when-done nil)
#+end_src

** Org Tangle
#+begin_src elisp
;; Org-auto-tangle
(use-package org-auto-tangle
  :defer t
  :hook (org-mode . org-auto-tangle-mode)
  :config
  (setq org-auto-tangle-default t))
#+end_src

** Org Agenda
#+begin_src elisp
;; Configure habit graph display
(setq org-habit-show-habits-only-for-today t)  ; or nil to show all days
(setq org-habit-graph-column 50)  ; adjust based on your screen

(setq org-agenda-remove-tags t)
(setq org-agenda-block-separator 32)
(setq org-agenda-custom-commands
      '(("d" "Dashboard"
         ((tags "PRIORITY=\"A\""
                ((org-agenda-skip-function '(org-agenda-skip-entry-if 'todo 'done))
                 (org-agenda-overriding-header "\n HIGHEST PRIORITY")
                 (org-agenda-prefix-format "   %i %?-2 t%s")))

          (agenda ""
                  ((org-agenda-start-day "+0d")
                   (org-agenda-span 3)  ; Show 3 days for better habit tracking
                   (org-agenda-time)
                   (org-agenda-remove-tags t)
                   (org-agenda-todo-keyword-format "")
                   (org-agenda-scheduled-leaders '("" ""))
                   (org-agenda-current-time-string "ᐊ┈┈┈┈┈┈┈┈┈ NOW")
                   (org-agenda-overriding-header "\n TODAY'S SCHEDULE & HABITS")
                   (org-agenda-prefix-format "   %i %?-2 t%s")))

          (tags-todo "-STYLE=\"habit\""  ; This still excludes habits from TODO list
                     ((org-agenda-overriding-header "\n ALL TODO")
                      (org-agenda-sorting-strategy '(priority-down))
                      (org-agenda-remove-tags t)
                      (org-agenda-prefix-format "   %i %?-2 t%s")))))))

(defun my/org-agenda-dashboard ()
  "Open the custom org-agenda dashboard."
  (interactive)
  (org-agenda nil "d"))
#+end_src

** Org capture templates
#+begin_src elisp
;; Mark tasks with a CLOSED timestamp on DONE
(after! org
(setq org-log-done 'time)

;; Capture templates
(setq org-capture-templates
      '(("t" "Todo" entry
         (file+headline "~/org/inbox.org" "Inbox")
         "* TODO %^{Task}\n:PROPERTIES:\n:CREATED: %U\n:CAPTURED: %a\n:END:\n%?")

        ("e" "Event" entry
         (file+headline "~/org/calendar.org" "Events")
         "* %^{Event}\n%^{SCHEDULED}T\n:PROPERTIES:\n:CREATED: %U\n:CAPTURED: %a\n:CONTACT: %(org-capture-ref-link \"~/org/roam/contacts.org\")\n:END:\n%?")

        ("d" "Deadline" entry
         (file+headline "~/org/calendar.org" "Deadlines")
         "* TODO %^{Task}\nDEADLINE: %^{Deadline}T\n:PROPERTIES:\n:CREATED: %U\n:CAPTURED: %a\n:END:\n%?")

        ("b" "Bookmark" entry
        (file+headline "~/org/bookmarks.org" "Inbox")
        "** [[%^{URL}][%^{Title}]]\n:PROPERTIES:\n:CREATED: %U\n:TAGS: %(org-capture-bookmark-tags)\n:END:\n\n"
        :empty-lines 0)

        ("c" "Contact" entry
         (file "~/org/roam/contacts.org")
"* %^{Name} %^g
:PROPERTIES:
:ID: %(org-id-new)
:CREATED: %U
:CAPTURED: %a
:EMAIL: %^{Email}
:PHONE: %^{Phone}
:BIRTHDAY: %^{Birthday (use <YYYY-MM-DD +1y> format)}t
:LOCATION: %^{Address}
:LAST_CONTACTED: %U
:END:
%?"
 :empty-lines 1)

        ("n" "Note" entry
         (file+headline "~/org/notes.org" "Inbox")
         "* [%<%Y-%m-%d %a>] %^{Title}\n:PROPERTIES:\n:CREATED: %U\n:CAPTURED: %a\n:END:\n%?"
         :prepend t)))

(defun org-capture-bookmark-tags ()
  "Get tags from existing bookmarks and prompt for tags with completion."
  (save-window-excursion
    (let ((tags-list '()))
      ;; Collect existing tags
      (with-current-buffer (find-file-noselect "~/org/bookmarks.org")
        (save-excursion
          (goto-char (point-min))
          (while (re-search-forward "^:TAGS:\\s-*\\(.+\\)$" nil t)
            (let ((tag-string (match-string 1)))
              (dolist (tag (split-string tag-string "[,;]" t "[[:space:]]"))
                (push (string-trim tag) tags-list))))))
      ;; Remove duplicates and sort
      (setq tags-list (sort (delete-dups tags-list) 'string<))
      ;; Prompt user with completion
      (let ((selected-tags (completing-read-multiple "Tags (comma-separated): " tags-list)))
        ;; Return as a comma-separated string
        (mapconcat 'identity selected-tags ", ")))))

;; Helper function to select and link a contact
(defun org-capture-ref-link (file)
  "Create a link to a contact in contacts.org"
  (let* ((headlines (org-map-entries
                     (lambda ()
                       (cons (org-get-heading t t t t)
                             (org-id-get-create)))
                     t
                     (list file)))
         (contact (completing-read "Contact: "
                                   (mapcar #'car headlines)))
         (id (cdr (assoc contact headlines))))
    (format "[[id:%s][%s]]" id contact))))

;; Set archive location to done.org under current date
;; (defun my/archive-done-task ()
;;   "Archive current task to done.org under today's date"
;;   (interactive)
;;   (let* ((date-header (format-time-string "%Y-%m-%d %A"))
;;          (archive-file (expand-file-name "~/org/done.org"))
;;          (location (format "%s::* %s" archive-file date-header)))
;;     ;; Only archive if not a habit
;;     (unless (org-is-habit-p)
;;       ;; Add COMPLETED property if it doesn't exist
;;       (org-set-property "COMPLETED" (format-time-string "[%Y-%m-%d %a %H:%M]"))
;;       ;; Set archive location and archive
;;       (setq org-archive-location location)
;;       (org-archive-subtree))))

;; Automatically archive when marked DONE, except for habits
;; (add-hook 'org-after-todo-state-change-hook
;;           (lambda ()
;;             (when (and (string= org-state "DONE")
;;                        (not (org-is-habit-p)))
;;               (my/archive-done-task))))

;; Optional key binding if you ever need to archive manually
(after! org
  (map! :map org-mode-map
        :localleader
        "a" #'my/archive-done-task))
#+end_src

** Calendar
#+begin_src emacs-lisp
(defun +calendar/open-calendar ()
  "Open calfw calendar with org integration."
  (interactive)
  (require 'calfw)
  (require 'calfw-org)
  
  ;; Apply Compline faces
  (custom-set-faces!
   '(cfw:face-title :foreground "#e0dcd4" :weight bold :height 1.2)
   '(cfw:face-header :foreground "#b8c4b8" :weight bold)
   '(cfw:face-sunday :foreground "#cdacac" :weight bold)
   '(cfw:face-saturday :foreground "#b4c0c8" :weight bold)
   '(cfw:face-grid :foreground "#282c34")
   '(cfw:face-today :background "#171a1e" :weight bold)
   '(cfw:face-select :background "#282c34" :foreground "#f0efeb")
   '(cfw:face-schedule :foreground "#b8c4b8")
   '(cfw:face-deadline :foreground "#cdacac"))
  
  (calfw-org-open-calendar))

;; Prevent byte-compilation of this function
(put '+calendar/open-calendar 'byte-compile 'byte-compile-file-form-defmumble)
#+end_src

** Org-contacts
#+begin_src emacs-lisp
(after! org
  (defvar my/contacts-file "~/org/roam/contacts.org")
  
  (defun my/contacts-get-emails ()
    "Extract all emails from contacts.org."
    (let (contacts)
      (with-current-buffer (find-file-noselect my/contacts-file)
        (org-with-wide-buffer
         (goto-char (point-min))
         (while (re-search-forward "^\\*+ \\(.+\\)$" nil t)
           (let ((name (match-string 1))
                 (email (org-entry-get (point) "EMAIL")))
             (when email
               (dolist (addr (split-string email "," t " "))
                 (push (cons name (string-trim addr)) contacts)))))))
      (nreverse contacts)))
  
  (defun my/contacts-complete ()
    "Complete email addresses from contacts.org."
    (let* ((end (point))
           (start (save-excursion
                    (skip-chars-backward "^:,; \t\n")
                    (point)))
           (contacts (my/contacts-get-emails))
           (collection (mapcar 
                       (lambda (contact)
                         (format "%s <%s>" (car contact) (cdr contact)))
                       contacts)))
      (list start end collection :exclusive 'no)))
  
  (add-hook 'message-mode-hook
            (lambda ()
              (setq-local completion-at-point-functions
                          (cons 'my/contacts-complete
                                completion-at-point-functions)))))

(after! mu4e
  (setq mu4e-compose-complete-addresses nil)
  
  (defun my/update-last-contacted ()
    (when (and (derived-mode-p 'mu4e-compose-mode)
               mu4e-compose-parent-message)
      (when-let* ((from (mu4e-message-field mu4e-compose-parent-message :from))
                  (email (if (stringp from) from (cdar from))))
        (when (stringp email)
          (with-current-buffer (find-file-noselect my/contacts-file)
            (save-excursion
              (goto-char (point-min))
              (when (search-forward email nil t)
                (org-back-to-heading)
                (org-set-property "LAST_CONTACTED" 
                                (format-time-string "[%Y-%m-%d %a %H:%M]"))
                (save-buffer))))))))
  
  (add-hook 'mu4e-compose-mode-hook #'my/update-last-contacted))
#+end_src

** Org Roam
#+begin_src elisp
(use-package! org-roam
  :defer t
  :commands (org-roam-node-find 
             org-roam-node-insert
             org-roam-dailies-goto-today
             org-roam-buffer-toggle
             org-roam-db-sync
             org-roam-capture)  ; Add this
  :init
  (setq org-roam-directory "~/org/roam"
        org-roam-database-connector 'sqlite-builtin
        org-roam-db-location (expand-file-name "org-roam.db" org-roam-directory)
        org-roam-v2-ack t)
  
  :config
  ;; Don't sync on startup, only when explicitly needed
  (setq org-roam-db-update-on-save nil)
  
  ;; Create directory if needed
  (unless (file-exists-p org-roam-directory)
    (make-directory org-roam-directory t))
  
  ;; Only enable autosync AFTER first use
  (add-hook 'org-roam-find-file-hook
            (lambda ()
              (unless org-roam-db-autosync-mode
                (org-roam-db-autosync-mode 1))))
  
  ;; CAPTURE TEMPLATES - Human readable filenames
  (setq org-roam-capture-templates
        '(("d" "default" plain "%?"
           :target (file+head "${slug}.org"
                              ":PROPERTIES:\n:ID:       %(org-id-new)\n:END:\n#+title: ${title}\n#+filetags: \n\n")
           :unnarrowed t)
          
          ("c" "concept" plain "%?"
           :target (file+head "concepts/${slug}.org"
                              ":PROPERTIES:\n:ID:       %(org-id-new)\n:END:\n#+title: ${title}\n#+filetags: :concept:\n\n")
           :unnarrowed t)

          ("C" "Contact" plain
          "* Contact Info
:PROPERTIES:
:EMAIL: %^{Email}
:PHONE: %^{Phone}
:BIRTHDAY: %^{Birthday (YYYY-MM-DD +1y)}t
:LOCATION: %^{Location}
:LAST_CONTACTED: %U
:END:

 ** Communications

 ** Notes
 %?"
 :target (file+head "contacts/${slug}.org"
 "#+title: ${title}
 #+filetags: %^{Tags}
 #+created: %U
 ")
 :unnarrowed t)
          
          
          ("b" "book" plain "%?"
           :target (file+head "books/${slug}.org"
                              ":PROPERTIES:\n:ID:       %(org-id-new)\n:END:\n#+title: ${title}\n#+author: \n#+filetags: :book:\n\n* Summary\n\n* Key Ideas\n\n* Quotes\n\n* Related\n\n")
           :unnarrowed t)
          
          ("p" "person" plain "%?"
           :target (file+head "people/${slug}.org"
                              ":PROPERTIES:\n:ID:       %(org-id-new)\n:END:\n#+title: ${title}\n#+filetags: :person:\n\n* Background\n\n* Key Ideas\n\n* Works\n\n")
           :unnarrowed t)
          
          ("t" "tech" plain "%?"
           :target (file+head "tech/${slug}.org"
                              ":PROPERTIES:\n:ID:       %(org-id-new)\n:END:\n#+title: ${title}\n#+filetags: :tech:\n\n")
           :unnarrowed t)
          
          ("T" "theology" plain "%?"
           :target (file+head "faith/theology/${slug}.org"
                              ":PROPERTIES:\n:ID:       %(org-id-new)\n:END:\n#+title: ${title}\n#+filetags: :theology:faith:\n\n* Doctrine\n\n* Scripture\n\n* Tradition\n\n* Application\n\n")
           :unnarrowed t)
          
          ("w" "writing" plain "%?"
           :target (file+head "writing/${slug}.org"
                              ":PROPERTIES:\n:ID:       %(org-id-new)\n:END:\n#+title: ${title}\n#+filetags: :writing:draft:\n\n")
           :unnarrowed t)
          
          ("P" "project" plain "%?"
           :target (file+head "projects/${slug}.org"
                              ":PROPERTIES:\n:ID:       %(org-id-new)\n:END:\n#+title: ${title}\n#+filetags: :project:private:\n\n* Overview\n\n* Goals\n\n* Status\n\n* Notes\n\n")
           :unnarrowed t)))
  
  ;; DAILIES - Clean date format
  (setq org-roam-dailies-directory "daily/"
        org-roam-dailies-capture-templates
        '(("d" "default" entry "* %<%H:%M>: %?"
           :target (file+head "%<%Y-%m-%d>.org"
                              ":PROPERTIES:\n:ID:       %(org-id-new)\n:END:\n#+title: %<%Y-%m-%d %A>\n#+filetags: :daily:\n\n"))))
  
  ;; Enable completion everywhere (for linking)
  (setq org-roam-completion-everywhere t))

;; org-roam-ui
(use-package! org-roam-ui
  :commands (org-roam-ui-mode org-roam-ui-open)
  :after org-roam
  :config
  (setq org-roam-ui-sync-theme t
        org-roam-ui-follow t
        org-roam-ui-update-on-save t
        org-roam-ui-open-on-start nil))
#+end_src

** Org keybinds
#+begin_src elisp
;; Keybinds for org mode
(with-eval-after-load 'org
  (define-key org-mode-map (kbd "C-c C-i") #'my/org-insert-image)
  (define-key org-mode-map (kbd "C-c e") #'org-set-effort)
  (define-key org-mode-map (kbd "C-c i") #'org-clock-in)
  (define-key org-mode-map (kbd "C-c o") #'org-clock-out))
#+end_src

** Custom function for image insertion
#+begin_src elisp
;; Insert image into org from selection
(defun my/org-insert-image ()
  "Select and insert an image into org file."
  (interactive)
  (let ((selected-file (read-file-name "Select image: " "~/Pictures/" nil t)))
    (when selected-file
      (insert (format "[[file:%s]]\n" selected-file))
      (org-display-inline-images))))
#+end_src

** Org Babel
#+begin_src elisp
;; (after! org
;;   (org-babel-do-load-languages
;;    'org-babel-load-languages
;;    '((go . t)))

;;   (setq org-src-fontify-natively t
;;         org-src-preserve-indentation t
;;         org-src-tab-acts-natively t
;;         ;; Don't save source edits in temp files
;;         org-src-window-setup 'current-window))

;; ;; Specifically for go-mode literate programming
;; (defun org-babel-edit-prep:go (babel-info)
;;   (when-let ((tangled-file (->> babel-info caddr (alist-get :tangle))))
;;     (let ((full-path (expand-file-name tangled-file)))
;;       ;; Don't actually create/modify the tangled file
;;       (setq-local buffer-file-name full-path)
;;       (lsp-deferred))))
#+end_src

* Evil mode setup
This sets up k-j as an evil escape sequence. Not used anymore due to setting esc keys in firmware.

#+begin_src elisp
;; Evil-escape sequence
(setq-default evil-escape-key-sequence "kj")
(setq-default evil-escape-delay 0.1)

; Don't move cursor back when exiting insert mode
(setq evil-move-cursor-back nil)
;; granular undo with evil mode
(setq evil-want-fine-undo t)
;; Enable paste from system clipboard with C-v in insert mode
(evil-define-key 'insert global-map (kbd "C-v") 'clipboard-yank)
#+end_src

* Vterm
#+begin_src elisp
;; Vterm adjustemts
(setq vterm-environment '("TERM=xterm-256color"))
(set-language-environment "UTF-8")
(set-default-coding-systems 'utf-8)
(custom-set-faces!
  '(vterm :family "Geistmono Nerd Font"))

;; open vterm in dired location
(after! vterm
  (setq vterm-buffer-name-string "vterm %s")

  ;; Modify the default vterm opening behavior
  (defadvice! +vterm-use-current-directory-a (fn &rest args)
    "Make vterm open in the directory of the current buffer."
    :around #'vterm
    (let ((default-directory (or (and (buffer-file-name)
                                      (file-name-directory (buffer-file-name)))
                                 (and (eq major-mode 'dired-mode)
                                      (dired-current-directory))
                                 default-directory)))
      (apply fn args)))

  ;; Also modify Doom's specific vterm functions
  (defadvice! +vterm-use-current-directory-b (fn &rest args)
    "Make Doom's vterm commands open in the directory of the current buffer."
    :around #'+vterm/here
    (let ((default-directory (or (and (buffer-file-name)
                                      (file-name-directory (buffer-file-name)))
                                 (and (eq major-mode 'dired-mode)
                                      (dired-current-directory))
                                 default-directory)))
      (apply fn args))))

(defun open-vterm-in-current-context ()
  "Open vterm in the context of the current buffer/window."
  (interactive)
  (when-let ((buf (current-buffer)))
    (with-current-buffer buf
      (call-interactively #'+vterm/here))))

(defun my-open-vterm-at-point ()
  "Open vterm in the directory of the currently selected window's buffer.
This function is designed to be called via `emacsclient -e`."
  (interactive)
  (let* ((selected-window (selected-window))
         ;; Ensure selected-window is not nil before trying to get its buffer
         (buffer-in-window (and selected-window (window-buffer selected-window)))
         dir)

    (when buffer-in-window
      (setq dir
            ;; Temporarily switch to the target buffer to evaluate its context
            (with-current-buffer buffer-in-window
              (cond ((buffer-file-name buffer-in-window)
                     (file-name-directory (buffer-file-name buffer-in-window)))
                    ((and (eq major-mode 'dired-mode)
                          (dired-current-directory))
                     (dired-current-directory))
                    (t default-directory)))))

    ;; Fallback to the server's default-directory if no specific directory was found
    (unless dir (setq dir default-directory))

    (message "Opening vterm in directory: %s" dir) ; For debugging, check *Messages* buffer

    ;; Now, crucially, set 'default-directory' for the vterm call itself
    (let ((default-directory dir))
      ;; Call the plain 'vterm' function, which should respect 'default-directory'.
      ;; We are *not* passing 'dir' as an argument to 'vterm' here,
      ;; as it's often designed to pick up the current 'default-directory'.
      (vterm))))
#+end_src

** Open new Frames with vterm as initial screen:
#+begin_src elisp
;; Define immediately, not wrapped in after!
(defun my/new-frame-with-vterm ()
  "Create a new frame and immediately open vterm in it."
  (interactive)
  (require 'vterm)
  (let ((new-frame (make-frame '((explicit-vterm . t)))))
    (select-frame new-frame)
    (delete-other-windows)
    ;; Force vterm to take full window
    (let ((vterm-buffer (vterm (format "*vterm-%s*" (frame-parameter new-frame 'name)))))
      (switch-to-buffer vterm-buffer)
      (delete-other-windows))))  ; Nuke any splits vterm created

;; Tag initial frame
(defun my/tag-initial-frame ()
  "Tag the first frame as main."
  (set-frame-parameter nil 'main-frame t))

(add-hook 'emacs-startup-hook #'my/tag-initial-frame)

;; Vterm auto-spawn hook - skip frames we've already handled
(after! vterm
  (defun my/vterm-in-new-frame (frame)
    "Open vterm only in additional frames, not the main frame or explicit frames."
    (unless (or (frame-parameter frame 'main-frame)
                (frame-parameter frame 'explicit-vterm))
      (with-selected-frame frame
        (delete-other-windows)
        (let ((vterm-buffer (vterm (format "*vterm-%s*" (frame-parameter frame 'name)))))
          (switch-to-buffer vterm-buffer)
          (delete-other-windows)))))
  
  (add-hook 'after-make-frame-functions #'my/vterm-in-new-frame))
#+end_src

* Development
** Emmet
#+begin_src elisp
;; Emmet remap
(add-hook 'sgml-mode-hook 'emmet-mode) ;; Auto-start on any markup modes
(add-hook 'css-mode-hook  'emmet-mode) ;; enable Emmet's css abbreviation.
(map! :map emmet-mode-keymap
      :n "<C-return>" #'emmet-expand-line)
(setq emmet-expand-jsx-className? t) ;; default nil
#+end_src

** LSP
#+begin_src elisp
;; LSP Performance optimizations and settings
(after! lsp-mode
  (setq lsp-idle-delay 0.5
        lsp-log-io nil
        lsp-completion-provider :capf
        lsp-completion-enable t              ; ADDED: explicitly enable completions
        lsp-enable-file-watchers nil
        lsp-auto-guess-root t
        lsp-enable-folding nil
        lsp-enable-text-document-color nil
        lsp-enable-on-type-formatting nil
        lsp-enable-snippet t                 ; CHANGED: was nil, must be t for completions
        lsp-enable-symbol-highlighting nil
        lsp-enable-links nil
        ;; lsp-auto-configure nil            ; REMOVED: this breaks completion registration
        lsp-restart 'auto-restart
        lsp-keep-workspace-alive nil         ; ADDED: cleanup dead workspaces
        ;; Go-specific settings
        lsp-go-hover-kind "FullDocumentation"
        lsp-go-analyses '((nilness . t)
                          (unusedwrite . t)
                          (unusedparams . t))
        ;; gopls settings
        lsp-gopls-completeUnimported t
        lsp-gopls-staticcheck t
        lsp-gopls-use-placeholders t         ; ADDED: needed for snippet support
        lsp-gopls-analyses '((unusedparams . t)
                             (unusedwrite . t)
                             (nilness . t))))

;; LSP UI settings
(after! lsp-ui
  (setq lsp-ui-doc-enable t
        lsp-ui-doc-position 'at-point
        lsp-ui-doc-max-height 8
        lsp-ui-doc-max-width 72
        lsp-ui-doc-show-with-cursor t
        lsp-ui-doc-delay 0.5
        lsp-ui-sideline-enable nil
        lsp-ui-peek-enable t))

;; Hook lsp to tree-sitter modes
(add-hook 'go-ts-mode-hook #'lsp-deferred)
(add-hook 'go-mod-ts-mode-hook #'lsp-deferred)

;; Ensure company-mode is enabled
(add-hook 'go-ts-mode-hook #'company-mode)

;; Optimize company backends for Go
(after! company
  (setq company-minimum-prefix-length 1
        company-idle-delay 0.2
        company-tooltip-align-annotations t)
  
  ;; Prioritize LSP completions over snippets in Go
  (add-hook 'go-ts-mode-hook
            (lambda ()
              (setq-local company-backends
                          '((company-capf :with company-yasnippet)
                            company-files)))))
;; Python LSP
(add-hook 'python-mode-hook #'lsp-deferred)

;; PHP LSP  
(add-hook 'php-mode-hook #'lsp-deferred)

;; C/C++ LSP
(add-hook 'c-mode-hook #'lsp-deferred)
(add-hook 'c++-mode-hook #'lsp-deferred)

;; C# LSP
(add-hook 'csharp-mode-hook #'lsp-deferred)

;; Lua LSP
(add-hook 'lua-mode-hook #'lsp-deferred)

;; Markdown LSP
(add-hook 'markdown-mode-hook #'lsp-deferred)

;; YAML LSP
(add-hook 'yaml-mode-hook #'lsp-deferred)

;; Tailwind LSP (already have web-mode, add CSS)
(add-hook 'css-mode-hook #'lsp-deferred)
(add-hook 'scss-mode-hook #'lsp-deferred)

#+end_src

** Project Detection
#+begin_src elisp
(after! project
  ;; Master project detection function - extensible for all project types
  (add-hook 'project-find-functions
            (lambda (dir)
              (cond
               ;; Go projects
               ((locate-dominating-file dir "go.mod")
                (cons 'transient (locate-dominating-file dir "go.mod")))

               ;; Rust projects
               ((locate-dominating-file dir "Cargo.toml")
                (cons 'transient (locate-dominating-file dir "Cargo.toml")))

               ;; Node.js projects
               ((locate-dominating-file dir "package.json")
                (cons 'transient (locate-dominating-file dir "package.json")))

               ;; Python projects (multiple markers)
               ((or (locate-dominating-file dir "pyproject.toml")
                    (locate-dominating-file dir "setup.py")
                    (locate-dominating-file dir "requirements.txt"))
                (cons 'transient (or (locate-dominating-file dir "pyproject.toml")
                                     (locate-dominating-file dir "setup.py")
                                     (locate-dominating-file dir "requirements.txt"))))

               ;; Generic git projects (fallback)
               ((locate-dominating-file dir ".git")
                (cons 'transient (locate-dominating-file dir ".git")))))))
#+end_src

** Web mode
Add Astro and svelte files to web-mode automatically:
#+begin_src elisp
(add-to-list 'auto-mode-alist '("\\.astro\\'" . web-mode))
(add-to-list 'auto-mode-alist '("\\.svelte\\'" . web-mode))

(set-file-template! "\\.astro$" :trigger "__astro" :mode 'web-mode)
(set-file-template! "\\.svelte$" :trigger "__svelte" :mode 'web-mode)
#+end_src

** Treesitter
#+begin_src elisp
;; Enable Treesitter for Go in org
(use-package! treesit
  :config
  ;; Define all language sources
  (setq treesit-language-source-alist
        '((go "https://github.com/tree-sitter/tree-sitter-go" "master" "src")
          (gomod "https://github.com/camdencheek/tree-sitter-go-mod" "main" "src")
          (javascript "https://github.com/tree-sitter/tree-sitter-javascript" "master" "src")
          (typescript "https://github.com/tree-sitter/tree-sitter-typescript" "master" "typescript/src")
          (tsx "https://github.com/tree-sitter/tree-sitter-typescript" "master" "tsx/src")
          (html "https://github.com/tree-sitter/tree-sitter-html" "master" "src")
          (css "https://github.com/tree-sitter/tree-sitter-css" "master" "src")
          (templ "https://github.com/vrischmann/tree-sitter-templ" "master" "src")))

;; Manual grammar installation command (invoke when needed)
(defun jb/install-treesit-grammars ()
  "Install missing tree-sitter grammars."
  (interactive)
  (dolist (lang '(go gomod javascript typescript tsx html css templ))
    (unless (treesit-language-available-p lang)
      (message "Installing grammar for %s..." lang)
      (treesit-install-language-grammar lang)))
  (message "Tree-sitter grammar installation complete!"))

  ;; Mode associations - prefer -ts-mode variants
  (setq major-mode-remap-alist
        '((javascript-mode . js-ts-mode)
          (typescript-mode . typescript-ts-mode)
          (css-mode . css-ts-mode)
          (html-mode . html-ts-mode))))


;; Org-babel integration with treesit
(after! org
  (setq org-src-lang-modes
        (append org-src-lang-modes
                '(("go" . go-ts)
                  ("javascript" . js-ts)
                  ("typescript" . typescript-ts)
                  ("html" . html-ts)
                  ("css" . css-ts)))))

;; Enhanced templ configuration with full HTML tooling
(use-package! templ-ts-mode
  :mode "\\.templ\\'"
  :after treesit
  :config
  ;; ALL lsp-mode modifications must be inside with-eval-after-load
  (with-eval-after-load 'lsp-mode
    ;; Configure the language ID INSIDE the eval-after-load block
    (add-to-list 'lsp-language-id-configuration '(templ-ts-mode . "templ"))

    ;; Primary templ LSP
    (lsp-register-client
     (make-lsp-client
      :new-connection (lsp-stdio-connection
                       (lambda ()
                         (if (executable-find "templ")
                             '("templ" "lsp")
                           (error "templ not found in PATH"))))
      :activation-fn (lsp-activate-on "templ")
      :server-id 'templ
      :major-modes '(templ-ts-mode)
      :priority 10))

    ;; HTML LSP for rich HTML completion
    (lsp-register-client
     (make-lsp-client
      :new-connection (lsp-stdio-connection "vscode-html-language-server" "--stdio")
      :activation-fn (lambda (file-name _mode)
                       (and (derived-mode-p 'templ-ts-mode)
                            (string-suffix-p ".templ" file-name)))
      :server-id 'html-templ
      :major-modes '(templ-ts-mode)
      :priority 5)))

  ;; Enable LSP
  (add-hook 'templ-ts-mode-hook #'lsp-deferred)

  ;; Enable Emmet for HTML expansions (div.hey -> <div class="hey"></div>)
  (add-hook 'templ-ts-mode-hook #'emmet-mode)

  ;; Enhanced company completion with HTML backends
  (after! company
    (set-company-backend! 'templ-ts-mode
      '(:separate
        company-capf              ; LSP completions (templ + HTML)
        company-web-html          ; HTML tag/attribute completion
        company-css               ; CSS class completion
        company-yasnippet         ; HTML snippets
        company-dabbrev)))        ; Buffer text

  ;; Enable web-mode style HTML completion features
  (add-hook 'templ-ts-mode-hook
            (lambda ()
              (setq-local company-minimum-prefix-length 1)
              (setq-local company-idle-delay 0.1)
              (when (featurep 'company-web-html)
                (add-to-list 'company-backends 'company-web-html))))

  ;; Configure Emmet for templ files
  (after! emmet-mode
    (add-to-list 'emmet-jsx-major-modes 'templ-ts-mode)
    (setq emmet-expand-jsx-className? t)))

;; File template
(set-file-template! "\\.templ$" :trigger "__templ" :mode 'templ-ts-mode)

;; Optional: Add HTML yasnippets to templ mode
(after! yasnippet
  (add-hook 'templ-ts-mode-hook
            (lambda ()
              (yas-activate-extra-mode 'html-mode))))
#+end_src

** Svelte and JS
#+begin_src elisp
;; Svelte mode
(use-package! svelte-mode
  :mode "\\.svelte\\'"  ; :defer t is implicit
  :hook (svelte-mode . prettier-js-mode)  ; Correct hook placement
  :config
  (setq svelte-basic-offset 2)
  (setq svelte-format-on-save nil))

;; Prettier configuration
(use-package! prettier-js
  :defer t
  :init  ; Use :init to set variables before package loads
  (setq prettier-js-args
        '("--parser" "svelte"
          "--tab-width" "2"
          "--use-tabs" "true")))
#+end_src

** Tailwind
#+begin_src elisp
;; Tailwind CSS
(use-package! lsp-tailwindcss
:defer t
  )
#+end_src

** Minimap (not using)
#+begin_src elisp
;; ;; Setup Minimap
;; (require 'sublimity)
;; (require 'sublimity-scroll)
;; (require 'sublimity-map) ;; experimental
;; (require 'sublimity-attractive)
;; ;; Minimap settings
;; (setq minimap-window-location 'right)
;; (map! :leader
;;       (:prefix ("t" . "toggle")
;;        :desc "Toggle minimap-mode" "m" #'minimap-mode))
#+end_src

** Treemacs
#+begin_src elisp
;; Treemacs
(require 'treemacs-all-the-icons)
(setq doom-themes-treemacs-theme "all-the-icons")
#+end_src

** AI
#+begin_src elisp
;; GPtel - Quick Claude chat via API (optional, for quick queries)
;; Only used when you run M-x gptel directly
;; Note: This uses Claude API (separate from your subscription)
(defun gptel-api-key ()
  "Read API key from pass - only if you want to use GPtel with API."
  (string-trim (shell-command-to-string "pass show claude/api-key")))

(use-package! gptel
  :defer t
  :config
  (setq gptel-backend
        (gptel-make-anthropic "Claude"
          :stream t
          :key #'gptel-api-key
          ;; Let it use the latest available models
          :models '(claude-sonnet-4-5
                    claude-opus-4-5
                    claude-sonnet-3-7))))
#+end_src

*** Claude Code IDE
#+begin_src elisp
(use-package! claude-code-ide
  :defer t
  :commands (claude-code-ide-start
             claude-code-ide-chat
             claude-code-ide-edit-file
             claude-code-ide-diff
             claude-code-ide-cancel
             claude-code-ide-add-file
             claude-code-ide-add-region
             claude-code-ide-clear-context)
  :config
  (setq claude-code-ide-model "claude-sonnet-4-20250514"
        claude-code-ide-max-tokens 8192
        claude-code-ide-temperature 0.7
        claude-code-ide-response-buffer-name "*Claude*"
        claude-code-ide-show-response-buffer t))
#+end_src

** Magit
#+begin_src elisp
(after! magit
  (defun my/magit-stage-commit-push ()
    "Stage all, commit with quick message, and push with no questions"
    (interactive)
    (magit-stage-modified)
    (let ((msg (read-string "Commit message: ")))
      (magit-commit-create (list "-m" msg))
      (magit-run-git "push" "origin" (magit-get-current-branch)))))
#+end_src

** DAP
#+begin_src elisp
(after! dap-mode
  :defer t
  (require 'dap-dlv-go)

  ;; Remove problematic hooks
  (remove-hook 'dap-stopped-hook 'dap-ui-repl-toggle)
  (remove-hook 'dap-session-created-hook 'dap-ui-mode))
#+end_src

** TRAMP
#+begin_src elisp
;;;; TRAMP optimizations
(after! tramp
  :defer t
  (setq tramp-default-method "ssh"          ; Use SSH by default
        tramp-verbose 1                      ; Reduce verbosity
        tramp-use-ssh-controlmaster-options nil  ; Don't use control master
        tramp-chunksize 500                 ; Bigger chunks for better performance
        tramp-connection-timeout 10         ; Shorter timeout
        ;; Use SSH configuration
        tramp-use-ssh-controlmaster-options nil
        ;; Cache remote files
        remote-file-name-inhibit-cache nil
        ;; Enable file-name-handler cache
        tramp-cache-read-persistent-data t))

;; Additional performance settings
(setq vc-ignore-dir-regexp
      (format "%s\\|%s"
              vc-ignore-dir-regexp
              tramp-file-name-regexp))
#+end_src

** SQL mode
#+begin_src elisp
(with-eval-after-load 'sql (load! "lisp/pg-config"))
#+end_src

*** Sqls
go install github.com/sqls-server/sqls@latest
#+begin_src elisp
;; LSP support for SQL files
(use-package lsp-sqls
  :after lsp-mode
  :hook (sql-mode . lsp-deferred)
  :config
  ;; Let sqls use the config file instead of hardcoded connections
  (setq lsp-sqls-workspace-config-path nil)) ; This tells it to look for .sqls.yml
#+end_src

** Docker
#+begin_src elisp
(setq docker-command "podman")
(setq docker-compose-command "podman-compose")
#+end_src
** Compilation
Changes environment to bash for compilation commands (ie. zig-run go-test etc.)

#+begin_src elisp
;; set compile to bash 
(setq shell-file-name "/run/current-system/sw/bin/bash")
;; Keep vterm as zsh
(setq vterm-shell "/run/current-system/sw/bin/zsh")
#+end_src

* Nix
** Nix LSP
#+begin_src elisp
(after! lsp-mode
  (lsp-register-client
   (make-lsp-client
    :new-connection (lsp-stdio-connection '("nixd"))
    :major-modes '(nix-mode nix-ts-mode)
    :server-id 'nixd
    :priority 1)))

(after! nix-mode
  (setq nix-nixfmt-bin "nixfmt"))
#+end_src
** Agenix
#+begin_src elisp
(use-package! agenix
  :defer t
  :config
  (setq agenix-secrets-file "~/nixos-config/secrets.nix")

  ;; Override the command to always use your identity
  (defun agenix--age-command (action file &rest args)
    (append (list "age" action "--identity" (expand-file-name "~/.ssh/phatlekey") file) args)))
#+end_src

* Writing
** Spelling
#+begin_src elisp
;; Spelling
(setq ispell-program-name "aspell")
(setq ispell-extra-args '("--sug-mode=ultra" "--lang=en_US"))
(setq spell-fu-directory "~/+STORE/dictionary") ;; Please create this directory manually.
(setq ispell-personal-dictionary "~/+STORE/dictionary/.pws")

;; Dictionary
(setq +lookup-dictionary-provider 'define-word)

;;Snippets
(yas-global-mode 1)
(add-hook 'yas-minor-mode-hook (lambda () (yas-activate-extra-mode 'fundamental-mode)))
#+end_src

** Writeroom/Zen modes
#+begin_src elisp
;; Setup writeroom width and appearance
(after! writeroom-mode
  ;; Set width for centered text
  (setq writeroom-width 40)

  ;; Ensure the text is truly centered horizontally
  (setq writeroom-fringes-outside-margins nil)
  (setq writeroom-center-text t)

  ;; Add vertical spacing for better readability
  (setq writeroom-extra-line-spacing 4)  ;; Adds space between lines

  ;; Improve vertical centering with visual-fill-column integration
  (add-hook! 'writeroom-mode-hook
    (defun my-writeroom-settings ()
      "Configure various settings when entering/exiting writeroom-mode."
      (if writeroom-mode
          (progn
            ;; When entering writeroom mode
            (display-line-numbers-mode -1)       ;; Turn off line numbers
            (setq cursor-type 'bar)              ;; Change cursor to a thin bar for writing
            (hl-line-mode -1)                    ;; Disable current line highlighting
            (setq left-margin-width 0)           ;; Let writeroom handle margins
            (setq right-margin-width 0)
            (text-scale-set 1)                   ;; Slightly increase text size

            ;; Improve vertical centering
            (when (bound-and-true-p visual-fill-column-mode)
              (visual-fill-column-mode -1))      ;; Temporarily disable if active
            (setq visual-fill-column-width 40)   ;; Match writeroom width
            (setq visual-fill-column-center-text t)
            (setq visual-fill-column-extra-text-width '(0 . 0))

            ;; Set top/bottom margins to improve vertical centering
            ;; These larger margins push content toward vertical center
            (setq-local writeroom-top-margin-size
                        (max 10 (/ (- (window-height) 40) 3)))
            (setq-local writeroom-bottom-margin-size
                        (max 10 (/ (- (window-height) 40) 3)))

            ;; Enable visual-fill-column for better text placement
            (visual-fill-column-mode 1))

        ;; When exiting writeroom mode
        (progn
          (display-line-numbers-mode +1)       ;; Restore line numbers
          (setq cursor-type 'box)              ;; Restore default cursor
          (hl-line-mode +1)                    ;; Restore line highlighting
          (text-scale-set 0)                   ;; Restore normal text size
          (when (bound-and-true-p visual-fill-column-mode)
            (visual-fill-column-mode -1))))))  ;; Disable visual fill column mode

  ;; Hide modeline for a cleaner look
  (setq writeroom-mode-line nil)

  ;; Add additional global effects for writeroom
  (setq writeroom-global-effects
        '(writeroom-set-fullscreen        ;; Enables fullscreen
          writeroom-set-alpha             ;; Adjusts frame transparency
          writeroom-set-menu-bar-lines
          writeroom-set-tool-bar-lines
          writeroom-set-vertical-scroll-bars
          writeroom-set-bottom-divider-width))

  ;; Set frame transparency
  (setq writeroom-alpha 0.95))
#+end_src

* Keybindings
** Zoom
#+begin_src elisp
;; zoom in/out like we do everywhere else.
(global-set-key (kbd "C-=") 'text-scale-increase)
(global-set-key (kbd "C--") 'text-scale-decrease)
#+end_src

** General
#+begin_src elisp
(map! :leader
      ;; AI keybindings - SPC a prefix
      :prefix ("a" . "ai")
      :desc "Chat with Claude" "c" #'claude-code-ide-chat
      :desc "Start Claude session" "s" #'claude-code-ide-start
      :desc "Edit current file" "e" #'claude-code-ide-edit-file
      :desc "Show diff" "d" #'claude-code-ide-diff
      :desc "Cancel request" "k" #'claude-code-ide-cancel
      :desc "Add file to context" "f" #'claude-code-ide-add-file
      :desc "Add region to context" "r" #'claude-code-ide-add-region
      :desc "Clear context" "x" #'claude-code-ide-clear-context)

      Quick access
      (map! :leader
      :desc "Quick Claude Chat" "C" #'claude-code-ide-chat)


      ;; GIT - SPC g
      (:prefix ("g" . "magit")
       :desc "Stage all files"          "a" #'magit-stage-modified
       :desc "Goto function definition" "d" #'evil-goto-definition
       :desc "Push"                     "P" #'magit-push
       :desc "Pull"                     "p" #'magit-pull
       :desc "Merge"                    "m" #'magit-merge
       :desc "Quick commit and push"    "z" #'my/magit-stage-commit-push)
      
      ;; ORG MODE - SPC y
      (:prefix ("y" . "org-mode-specifics")
       :desc "MU4E org mode"                    "m" #'mu4e-org-mode
       :desc "Mail add attachment"              "a" #'mail-add-attachment
       :desc "Export as markdown"               "e" #'org-md-export-as-markdown
       :desc "Preview markdown file"            "p" #'markdown-preview
       :desc "Export as html"                   "h" #'org-html-export-as-html
       :desc "Org Roam UI"                      "u" #'org-roam-ui-mode
       :desc "Search dictionary at word"        "d" #'dictionary-lookup-definition
       :desc "Powerthesaurus lookup word"       "t" #'powerthesaurus-lookup-word-at-point
       :desc "Read Aloud This"                  "r" #'read-aloud-this
       :desc "Export as LaTeX then PDF"         "l" #'org-latex-export-to-pdf
       :desc "Spell check"                      "z" #'ispell-word
       :desc "Find definition"                  "f" #'lsp-find-definition)
      
      ;; COMMUNICATIONS & AI - SPC e
      (:prefix ("e" . "Elfeed/ERC/AI")
       :desc "Open elfeed"              "e" #'elfeed
       :desc "Update elfeed"            "u" #'elfeed-update
       :desc "MPV watch video"          "v" #'elfeed-tube-mpv
       :desc "Open ERC (IRC)"           "r" #'erc
       :desc "Open EWW Browser"         "w" #'eww
       :desc "Open Elpher"              "l" #'elpher
       :desc "Open Pass"                "p" #'pass
       :desc "Open Matrix"              "m" #'my/matrix-connect
       :desc "Matrix view room"         "M" #'my/matrix-room
       (:prefix ("S" . "Signal")
        :desc "Open gurk TUI"           "s" #'my/signal-open
        :desc "Signal Desktop"          "d" #'my/signal-desktop
        :desc "Send quick message"      "m" #'my/signal-send-quick
        :desc "Edit config"             "c" #'my/signal-config)
       :desc "Claude chat (gptel)"      "g" #'gptel)
      
      ;; OPEN COMMANDS - SPC o
      (:prefix ("o" . "open")
       :desc "Calendar"                  "c" #'=calendar
       :desc "Bookmarks"                 "l" #'list-bookmarks
       :desc "Dirvish"                   "d" #'dirvish
       :desc "Refresh GPG passphrase"    "g" #'my/preset-gpg-passphrase)
      
      ;; BUFFER - SPC b
      (:prefix ("b" . "+buffer")
       :desc "Save Bookmarks"            "P" #'bookmark-save)
      
      ;; SEARCH - SPC s
      (:prefix-map ("s" . "search")
       :desc "Search project"            "p" #'consult-ripgrep
       :desc "Search buffer"             "s" #'consult-line
       :desc "Search project files"      "f" #'consult-find
       :desc "Command history"           "h" #'consult-history
       :desc "Recent directories"        "d" #'consult-dir)
      
      ;; EMBARK - SPC k
      (:prefix ("k" . "embark")
       :desc "Embark act"                "a" #'embark-act
       :desc "Embark dwim"               "d" #'embark-dwim
       :desc "Embark collect"            "c" #'embark-collect))

;; Saving
(map! "C-s" #'save-buffer)

;; Moving between splits
(map! :map general-override-mode-map
      "C-<right>" #'evil-window-right
      "C-<left>"  #'evil-window-left
      "C-<up>"    #'evil-window-up
      "C-<down>"  #'evil-window-down
      ;; Window resizing with Shift
      "S-<right>" (lambda () (interactive)
                    (if (window-in-direction 'left)
                        (evil-window-decrease-width 5)
                      (evil-window-increase-width 5)))
      "S-<left>"  (lambda () (interactive)
                    (if (window-in-direction 'right)
                        (evil-window-decrease-width 5)
                      (evil-window-increase-width 5)))
      "S-<up>"    (lambda () (interactive)
                    (if (window-in-direction 'below)
                        (evil-window-decrease-height 2)
                      (evil-window-increase-height 2)))
      "S-<down>"  (lambda () (interactive)
                    (if (window-in-direction 'above)
                        (evil-window-decrease-height 2)
                      (evil-window-increase-height 2))))

(map! :n "<C-tab>"   #'centaur-tabs-forward
      :n "<C-iso-lefttab>" #'centaur-tabs-backward)

;; setting avy for quick jump forward/backward
(define-key evil-normal-state-map "f" 'avy-goto-char-2)
(define-key evil-normal-state-map "F" 'avy-goto-char-2)

(after! org
;; Enable arrow keys in org-read-date calendar popup
(define-key org-read-date-minibuffer-local-map (kbd "<left>") (lambda () (interactive) (org-eval-in-calendar '(calendar-backward-day 1))))
(define-key org-read-date-minibuffer-local-map (kbd "<right>") (lambda () (interactive) (org-eval-in-calendar '(calendar-forward-day 1))))
(define-key org-read-date-minibuffer-local-map (kbd "<up>") (lambda () (interactive) (org-eval-in-calendar '(calendar-backward-week 1))))
(define-key org-read-date-minibuffer-local-map (kbd "<down>") (lambda () (interactive) (org-eval-in-calendar '(calendar-forward-week 1)))))
#+end_src

** Projectile
#+begin_src elisp
(after! projectile
  (setq projectile-enable-caching t)
  (setq projectile-indexing-method 'hybrid))
#+end_src

** Workspaces
#+begin_src elisp
(after! persp-mode
  (setq persp-auto-save-opt 1)  ; Still save on exit
  (setq persp-auto-resume-time 0)  ; Don't auto-restore
  (setq persp-set-last-persp-for-new-frames nil)
  (setq persp-reset-windows-on-nil-window-conf nil))

;; Manually restore when ready
;; M-x persp-load-state-from-file
#+end_src

* Media and Communications
** EMMS - Music Player
#+begin_src elisp
;; EMMS music player
(use-package! emms
  :defer t
  :commands (emms emms-browser emms-playlist-mode-go
             emms-pause emms-stop emms-next emms-previous emms-shuffle)
  :init
  (setq emms-source-file-default-directory "~/MusicOrganized"
        emms-playlist-buffer-name "*Music*"
        emms-info-asynchronously t
        emms-browser-default-browse-type 'artist)
  
  :config
  (emms-all)
  (emms-default-players)
  (emms-mode-line-mode 1)
  (emms-playing-time-mode 1)

  (setq emms-browser-covers #'emms-browser-cache-thumbnail-async
        emms-browser-thumbnail-small-size 64
        emms-browser-thumbnail-medium-size 128
        emms-source-file-directory-tree-function 'emms-source-file-directory-tree-find)

  ;; MPD integration
  (require 'emms-player-mpd)
  (setq emms-player-mpd-server-name "localhost"
        emms-player-mpd-server-port "6600"
        emms-player-mpd-music-directory (expand-file-name "~/MusicOrganized"))

  (add-to-list 'emms-player-list 'emms-player-mpd)
  (add-to-list 'emms-info-functions 'emms-info-mpd)
  (run-with-timer 0.1 nil #'emms-player-mpd-connect)
  
  (setq emms-player-list '(emms-player-mpd)))
#+end_src

** Spotify Integration
*** Spotifyd Daemon
#+begin_src elisp
(defun my/spotifyd-start ()
  "Start spotifyd daemon."
  (interactive)
  (async-shell-command "spotifyd --no-daemon" "*spotifyd*")
  (message "Spotifyd started - device: Marko-NixOS"))

(defun my/spotifyd-stop ()
  "Stop spotifyd."
  (interactive)
  (shell-command "killall spotifyd")
  (message "Spotifyd stopped"))

(defun my/spotifyd-restart ()
  "Restart spotifyd."
  (interactive)
  (my/spotifyd-stop)
  (sit-for 1)
  (my/spotifyd-start))

(defun my/spotify-info ()
  "Show track info."
  (interactive)
  (let ((info (shell-command-to-string
               "playerctl -p spotifyd metadata --format '{{ artist }} - {{ title }}' 2>/dev/null")))
    (if (string-empty-p (string-trim info))
        (message "Spotifyd not playing")
      (message "♫ %s" (string-trim info)))))

(defun my/spotify-play-pause ()
  "Toggle playback."
  (interactive)
  (shell-command "playerctl -p spotifyd play-pause 2>/dev/null")
  (sit-for 0.2)
  (my/spotify-info))

(defun my/spotify-next ()
  "Next track."
  (interactive)
  (shell-command "playerctl -p spotifyd next 2>/dev/null")
  (sit-for 0.5)
  (my/spotify-info))

(defun my/spotify-prev ()
  "Previous track."
  (interactive)
  (shell-command "playerctl -p spotifyd previous 2>/dev/null")
  (sit-for 0.5)
  (my/spotify-info))
#+end_src

*** Spotifydl Downloads
#+begin_src elisp
(defun my/spotifydl-track ()
  "Download track."
  (interactive)
  (let ((url (read-string "Track URL: "))
        (dir (read-directory-name "Save to: " "~/MusicOrganized/")))
    (async-shell-command
     (format "spotifydl download --url '%s' --output '%s'" url dir)
     "*spotifydl*")
    (message "Downloading to %s" dir)))

(defun my/spotifydl-playlist ()
  "Download playlist."
  (interactive)
  (let ((url (read-string "Playlist URL: "))
        (dir (read-directory-name "Save to: " "~/MusicOrganized/")))
    (async-shell-command
     (format "spotifydl download --url '%s' --output '%s'" url dir)
     "*spotifydl*")
    (message "Downloading playlist to %s" dir)))

(defun my/spotifydl-album ()
  "Download album."
  (interactive)
  (let ((url (read-string "Album URL: "))
        (dir (read-directory-name "Save to: " "~/MusicOrganized/")))
    (async-shell-command
     (format "spotifydl download --url '%s' --output '%s'" url dir)
     "*spotifydl*")
    (message "Downloading album to %s" dir)))

(defun my/spotifydl-from-clipboard ()
  "Download from clipboard."
  (interactive)
  (let ((url (current-kill 0))
        (dir (read-directory-name "Save to: " "~/MusicOrganized/")))
    (if (string-match-p "spotify\\.com\\|spotify:" url)
        (progn
          (async-shell-command
           (format "spotifydl download --url '%s' --output '%s'" url dir)
           "*spotifydl*")
          (message "Downloading from clipboard"))
      (message "No Spotify URL in clipboard"))))
#+end_src


*** Music Keybindings
#+begin_src elisp
;; MUSIC - SPC m (PROPERLY NESTED)
(map! :leader
      :prefix ("m" . "music")
      
      ;; ─── EMMS - Primary music player (top level) ───
      :desc "EMMS Browser"             "e" #'emms-browser
      :desc "EMMS Playlist"            "p" #'emms-playlist-mode-go
      :desc "Play/Pause"               "SPC" #'emms-pause
      :desc "Stop"                     "s" #'emms-stop
      :desc "Next"                     "n" #'emms-next
      :desc "Previous"                 "b" #'emms-previous
      :desc "Shuffle"                  "h" #'emms-shuffle
      :desc "Update from MPD"          "u" #'my/update-emms-from-mpd
      :desc "Play directory tree"      "d" #'emms-play-directory-tree
      
      ;; ─── Spotify API (Smudge) - nested ───
      (:prefix ("S" . "spotify-smudge")
       :desc "Play/Pause"               "SPC" #'smudge-controller-toggle-play
       :desc "Next track"               "n" #'smudge-controller-next-track
       :desc "Previous track"           "p" #'smudge-controller-previous-track
       :desc "Search track"             "t" #'smudge-track-search
       :desc "Search playlist"          "l" #'smudge-playlist-search
       :desc "My playlists"             "m" #'smudge-my-playlists
       :desc "Recently played"          "r" #'smudge-recently-played
       :desc "Current track"            "i" #'smudge-track-info)
      
      ;; ─── Spotifyd Daemon - nested ───
      (:prefix ("D" . "daemon")
       :desc "Start"                    "s" #'my/spotifyd-start
       :desc "Stop"                     "k" #'my/spotifyd-stop
       :desc "Restart"                  "r" #'my/spotifyd-restart
       :desc "Info"                     "i" #'my/spotify-info
       :desc "Play/Pause"               "SPC" #'my/spotify-play-pause
       :desc "Next"                     "n" #'my/spotify-next
       :desc "Previous"                 "p" #'my/spotify-prev)
      
      ;; ─── Downloads - nested ───
      (:prefix ("l" . "download")
       :desc "Track"                    "t" #'my/spotifydl-track
       :desc "Playlist"                 "p" #'my/spotifydl-playlist
       :desc "Album"                    "a" #'my/spotifydl-album
       :desc "From clipboard"           "c" #'my/spotifydl-from-clipboard))
#+end_src

*** Smudge Configuration (Spotify Web API)
#+begin_src elisp
;; Smudge - Full Spotify integration via Web API
;; Ready for when Spotify reopens developer app registration
;; Docs: https://github.com/danielfm/smudge

;; Step 1: Create app at https://developer.spotify.com/dashboard
;; Step 2: Add redirect URI: http://localhost:8080/smudge-api-callback
;; Step 3: Store credentials in pass:
;;         pass insert spotify/client-id
;;         pass insert spotify/client-secret

(use-package! smudge
  :defer t
  :commands (smudge-controller-toggle-play
             smudge-controller-next-track
             smudge-controller-previous-track
             smudge-track-search
             smudge-playlist-search
             smudge-my-playlists
             smudge-recently-played
             smudge-track-info)
  :config
  (setq smudge-oauth2-client-id 
        (string-trim (shell-command-to-string "pass show spotify/client-id"))
        smudge-oauth2-client-secret 
        (string-trim (shell-command-to-string "pass show spotify/client-secret"))
        smudge-player-status-format "♫ %a - %t"))
#+end_src

** Reading
*** Nov.el
#+begin_src elisp
;; Nov.el customizations and setup
(setq nov-unzip-program (executable-find "bsdtar")
      nov-unzip-args '("-xC" directory "-f" filename))
(add-to-list 'auto-mode-alist '("\\.epub\\'" . nov-mode))

#+end_src
*** Calibre
#+begin_src elisp
;; In config.el
(use-package! calibredb
:defer t
  :commands calibredb
  :config
  (setq calibredb-root-dir "~/Library"
        calibredb-db-dir (expand-file-name "metadata.db" calibredb-root-dir)
        calibredb-library-alist '(("~/Library"))
        calibredb-format-all-the-icons t)

  ;; Set up key bindings for calibredb-search-mode
  (map! :map calibredb-search-mode-map
        :n "RET" #'calibredb-find-file
        :n "?" #'calibredb-dispatch
        :n "a" #'calibredb-add
        :n "d" #'calibredb-remove
        :n "j" #'calibredb-next-entry
        :n "k" #'calibredb-previous-entry
        :n "l" #'calibredb-open-file-with-default-tool
        :n "s" #'calibredb-set-metadata-dispatch
        :n "S" #'calibredb-switch-library
        :n "q" #'calibredb-search-quit))
#+end_src

** Mu4e
#+begin_src elisp
;; Make system mu4e visible to Doom
(when-let ((mu4e-path (car (split-string
                           (shell-command-to-string
                            "find /nix/store -name 'mu4e.el' -path '*/share/emacs/site-lisp/*' 2>/dev/null | head -1")
                           "\n"))))
  (when (file-exists-p mu4e-path)
    (add-to-list 'load-path (file-name-directory mu4e-path))))

(after! mu4e
  (setq mu4e-mu-binary (executable-find "mu"))
  (setq mu4e-update-interval (* 10 60))
  (load (expand-file-name "private/mu4e-config.el" doom-private-dir)))

;; open mail links in mu4e
(defun mu4e-compose-mailto (url)
  "Compose from mailto: URL."
  (require 'url-parse)
  (require 'mu4e)
  (let* ((parsed (url-generic-parse-url url))
         (to (url-filename parsed))
         (query (url-target parsed))
         (headers (when query (url-parse-query-string query))))
    (mu4e-compose-new)
    (message-goto-to)
    (insert to)
    (when-let ((subject (cadr (assoc "subject" headers))))
      (message-goto-subject)
      (insert (url-unhex-string subject)))
    (when-let ((body (cadr (assoc "body" headers))))
      (message-goto-body)
      (insert (url-unhex-string body)))))
#+end_src

** Elfeed
#+begin_src elisp
;; Load elfeed-download package
(after! elfeed
  (load! "lisp/elfeed-download")
  (require 'elfeed-org)
  (elfeed-org)
  (elfeed-download-setup))

(make-directory "~/.elfeed" t)

;; Set org feed file
(setq rmh-elfeed-org-files '("~/.config/doom/elfeed.org"))

;; Configure elfeed - consolidate all elfeed config in one after! block
(after! elfeed
  (setq elfeed-db-directory "~/.elfeed")
  (setq elfeed-search-filter "@1-week-ago +unread -4chan -news -Reddit")

  ;; Set up elfeed-download
  (elfeed-download-setup)

  ;; Key bindings
  (map! :map elfeed-search-mode-map
        :n "d" #'elfeed-download-current-entry
        :n "O" #'elfeed-search-browse-url))

;; Update hourly
(run-at-time nil (* 60 60) #'elfeed-update)

;; Elfeed-tube configuration
(use-package! elfeed-tube
  :after elfeed
  :config
  (elfeed-tube-setup)
  :bind (:map elfeed-show-mode-map
         ("F" . elfeed-tube-fetch)
         ([remap save-buffer] . elfeed-tube-save)
         :map elfeed-search-mode-map
         ("F" . elfeed-tube-fetch)
         ([remap save-buffer] . elfeed-tube-save)))
#+end_src

** Gnus
#+begin_src elisp
(after! gnus
  ;; === SERVER CONNECTION ===
  (setq gnus-select-method
        '(nntp "news.eternal-september.org"
               (nntp-address "news.eternal-september.org")
               (nntp-port-number 119)
               (nntp-stream-type starttls)
               ))

  (setq canlock-password
        (with-temp-buffer
          (insert-file-contents "/run/agenix/canlock")
          (string-trim (buffer-string))))

  (setq user-full-name
        (with-temp-buffer
          (insert-file-contents "/run/agenix/gnus-name")
          (string-trim (buffer-string))))

  (setq user-mail-address
        (with-temp-buffer
          (insert-file-contents "/run/agenix/gnus-email")
          (string-trim (buffer-string))))

  ;; === LOCAL STORAGE ===
  (setq gnus-directory "~/.local/share/gnus/"
        gnus-cache-directory "~/.local/share/gnus/cache/"
        gnus-article-save-directory "~/.local/share/gnus/saved/"
        message-directory "~/.local/share/gnus/mail/")

  ;; === THREADING ===
  (setq gnus-summary-thread-gathering-function 'gnus-gather-threads-by-references
        gnus-thread-sort-functions '(gnus-thread-sort-by-most-recent-date)
        gnus-thread-hide-subtree nil)

  ;; === VISUAL PRESENTATION ===
  (setq gnus-summary-line-format "%U%R %20,20f  %B%s\n"
        gnus-sum-thread-tree-root "● "
        gnus-sum-thread-tree-false-root "◎ "
        gnus-sum-thread-tree-single-indent "◉ "
        gnus-sum-thread-tree-indent "  "
        gnus-sum-thread-tree-leaf-with-other "├─► "
        gnus-sum-thread-tree-single-leaf "╰─► "
        gnus-sum-thread-tree-vertical "│ ")

  ;; === BEHAVIOR ===
  (setq gnus-asynchronous t
        gnus-use-cache t
        gnus-use-scoring t
        message-kill-buffer-on-exit t
        gnus-treat-strip-trailing-blank-lines t)

  ;; === AUTO-SUBSCRIPTION ===
  (defvar my-gnus-subscribed-groups
    '("alt.cyberpunk.tech"
      "alt.cyberpunk"
      "comp.lang.go"
      "comp.os.linux.development.apps"
      "comp.editors"
      "comp.arch"
      "comp.programming"
      "comp.unix.programmer"
      "alt.philosophy.debate"
      "soc.religion.christian"
      "alt.privacy.anon-server"
      "comp.risks"
      "misc.writing")
    "Newsgroups to auto-subscribe on first connection.")

  (defun my-gnus-auto-subscribe-groups ()
    "Subscribe to groups in `my-gnus-subscribed-groups' if not already subscribed."
    (interactive)
    (dolist (group my-gnus-subscribed-groups)
      (let ((full-group (concat "nntp+news.eternal-september.org:" group)))
        (unless (gnus-group-entry full-group)
          (gnus-subscribe-group full-group)
          (message "Subscribed to %s" group)))))

  (add-hook 'gnus-started-hook #'my-gnus-auto-subscribe-groups)

  ;; === UI ENHANCEMENTS ===
  (add-hook 'gnus-group-mode-hook #'gnus-topic-mode)

  (custom-set-faces!
    '(gnus-summary-normal-unread :inherit font-lock-keyword-face)
    '(gnus-summary-selected :inherit (bold highlight))))
#+end_src

** Dirvish
#+begin_src elisp
;; Open dirvish
(map! :leader
      :desc "Open dirvish" "o d" #'dirvish)
#+end_src

** Graphical File management
Sometimes, we need to drag and drop files to GUIs - I previously was using dragon for this, but instead setup a way to just open nautilus at the dired/dirvish location in emacs, which is a better experience

Attempt to get files sent to browser or thunderbird
#+begin_src elisp
(defun my/dired-copy-file-directory ()
  "Copy directory of file at point and switch to workspace 2"
  (interactive)
  (let ((file (dired-get-filename)))
    ;; Copy directory
    (call-process "~/.config/scripts/upload-helper.sh" nil 0 nil file)
    ;; Switch workspace using shell command (like your working binding)
    (shell-command "hyprctl dispatch workspace 2")
    (message "File's directory copied, switched to workspace 2")))

;; Bind to "yu"
(after! dired
  (map! :map dired-mode-map
        :n "yu" #'my/dired-copy-file-directory))

(after! dirvish
  (map! :map dirvish-mode-map
        :n "yu" #'my/dired-copy-file-directory))
#+end_src

#+begin_src elisp
;; Open file manager in place dirvish/dired
(defun open-thunar-here ()
  "Open thunar in the current directory shown in dired/dirvish."
  (interactive)
  (let ((dir (cond
              ;; If we're in dired mode
              ((derived-mode-p 'dired-mode)
               default-directory)
              ;; If we're in dirvish mode (dirvish is derived from dired)
              ((and (featurep 'dirvish)
                    (derived-mode-p 'dired-mode)
                    (bound-and-true-p dirvish-directory))
               (or (bound-and-true-p dirvish-directory) default-directory))
              ;; Fallback for any other mode
              (t default-directory))))
    (message "Opening thunar in: %s" dir)  ; Helpful for debugging
    (start-process "thunar" nil "thunar" dir)))
;; Bind it to Ctrl+Alt+f in both dired and dirvish modes
(with-eval-after-load 'dired
  (define-key dired-mode-map (kbd "C-M-f") 'open-thunar-here))
;; For dirvish, we need to add our binding to its special keymap if it exists
(with-eval-after-load 'dirvish
  (if (boundp 'dirvish-mode-map)
      (define-key dirvish-mode-map (kbd "C-M-f") 'open-thunar-here)
    ;; Alternative approach if dirvish uses a different keymap system
    (add-hook 'dirvish-mode-hook
              (lambda ()
                (local-set-key (kbd "C-M-f") 'open-thunar-here)))))
#+end_src

** Emacs everywhere
#+begin_src elisp
(defun thanos/wtype-text (text)
  "Process TEXT for wtype, handling newlines properly."
  (let* ((has-final-newline (string-match-p "\n$" text))
         (lines (split-string text "\n"))
         (last-idx (1- (length lines))))
    (string-join
     (cl-loop for line in lines
              for i from 0
              collect (cond
                       ;; Last line without final newline
                       ((and (= i last-idx) (not has-final-newline))
                        (format "wtype \"%s\""
                                (replace-regexp-in-string "\"" "\\\\\"" line)))
                       ;; Any other line
                       (t
                        (format "wtype \"%s\" && wtype -k Return"
                                (replace-regexp-in-string "\"" "\\\\\"" line)))))
     " && ")))

(define-minor-mode thanos/type-mode
  "Minor mode for inserting text via wtype."
  :keymap `((,(kbd "C-c C-c") . ,(lambda () (interactive)
                                   (call-process-shell-command
                                    (thanos/wtype-text (buffer-string))
                                    nil 0)
                                   (delete-frame)))
            (,(kbd "C-c C-k") . ,(lambda () (interactive)
                                   (kill-buffer (current-buffer))))))

(defun thanos/type ()
  "Launch a temporary frame with a clean buffer for typing."
  (interactive)
  (let ((frame (make-frame '((name . "emacs-float")
                             (fullscreen . 0)
                             (undecorated . t)
                             (width . 70)
                             (height . 20))))
        (buf (get-buffer-create "emacs-float")))
    (select-frame frame)
    (switch-to-buffer buf)
    (with-current-buffer buf
      (erase-buffer)
      (org-mode)
      (flyspell-mode)
      (thanos/type-mode)
      (setq-local header-line-format
                  (format " %s to insert text or %s to cancel."
                          (propertize "C-c C-c" 'face 'help-key-binding)
			  (propertize "C-c C-k" 'face 'help-key-binding)))
      ;; Make the frame more temporary-like
      (set-frame-parameter frame 'delete-before-kill-buffer t)
      (set-window-dedicated-p (selected-window) t))))
#+end_src

** CIRCE (IRC)
#+begin_src elisp
;; Load private IRC configuration
;; (load! "private/irc-config" nil t)

;; (after! circe

;;   ;; Rest of your configuration remains the same
;;   (setq circe-format-self-say "{nick}: {body}")
;;   (setq circe-format-server-topic "*** Topic: {topic-diff}")
;;   (setq circe-use-cycle-completion t)
;;   (setq circe-reduce-lurker-spam t)

;;   (setq lui-max-buffer-size 30000)
;;   (enable-lui-autopaste)
;;   (enable-lui-irc-colors)

;;   (tracking-mode 1)
;;   (setq tracking-faces-priorities '(circe-highlight-nick-face))
;;   (setq tracking-ignored-buffers '("*circe-network-Rizon*"))

;;   (setq circe-highlight-nick-type 'all)

;;   (setq circe-directory "~/.doom.d/circe-logs")
;;   (setq lui-logging-directory "~/.doom.d/circe-logs")
;;   (setq lui-logging-file-format "{buffer}/%Y-%m-%d.txt")
;;   (setq lui-logging-format "[%H:%M:%S] {text}")
;;   (enable-lui-logging-globally)

;;   (unless (file-exists-p "~/.doom.d/circe-logs")
;;     (make-directory "~/.doom.d/circe-logs" t)))

;; (defun my/irc-connect-rizon ()
;;   "Connect to Rizon IRC."
;;   (interactive)
;;   (circe "Rizon"))

;; (map! :leader
;;       (:prefix ("o" . "open")
;;        :desc "Connect to Rizon IRC" "i" #'my/irc-connect-rizon))
#+end_src

** ERC
#+begin_src elisp
(defun my/erc-connect ()
  "Connect to IRC using credentials from authinfo.gpg."
  (interactive)
  (let* ((server (string-trim (shell-command-to-string "pass show irc/server")))
         (nick (string-trim (shell-command-to-string "pass show irc/nick")))
         (password (auth-source-pick-first-password :host server :user nick)))
    (if password
        (erc-tls :server server
                 :port 6697
                 :nick nick
                 :password password)
      (message "IRC password not found in authinfo.gpg"))))
(setq erc-autojoin-channels-alist
      '(("libera" "#technicalrenaissance" "#emacs" "#go-nuts" "#systemcrafters" "nixos" ))
      erc-track-shorten-start 8
      erc-kill-buffer-on-part t
      erc-auto-query 'bury)
#+end_src

** Matrix (Ement.el)
#+begin_src elisp
;; Matrix client using ement.el
(use-package! ement
  :defer t
  :commands (ement-connect ement-view-room)
  :config
  ;; Save session automatically
  (setq ement-save-sessions t)
  
  ;; Room display settings
  (setq ement-room-send-message-filter 'ement-room-send-org-filter)
  
  ;; Notifications
  (setq ement-notify-notification-method 'notifications)
  
  ;; Room list format
  (setq ement-room-list-avatars nil)  ; Disable avatars for performance
  
  ;; Message format
  (setq ement-room-message-format-spec "%S%B%r%R%t"))

;; Helper function for quick connection
(defun my/matrix-connect ()
  "Connect to Matrix homeserver."
  (interactive)
  (ement-connect))

;; Helper to view specific room
(defun my/matrix-room ()
  "View a Matrix room."
  (interactive)
  (call-interactively #'ement-view-room))
#+end_src

** Signal (gurk-rs TUI)
#+begin_src elisp
;; Signal integration using gurk-rs (Rust TUI)
;; Works perfectly in vterm inside Emacs
;; Requires: gurk-rs (installed via nixpkgs)

;; Phone number loaded from pass (keeps it private)
(defvar my/signal-phone nil
  "Signal phone number from pass.")

(defun my/signal-load-phone ()
  "Load Signal phone number from pass."
  (unless my/signal-phone
    (setq my/signal-phone
          (string-trim
           (shell-command-to-string "pass show signal/phone")))))

;; Main function - opens gurk-rs in vterm
(defun my/signal-open ()
  "Open Signal using gurk-rs TUI in vterm."
  (interactive)
  (my/signal-load-phone)
  (let ((vterm-buffer-name "*Signal (gurk-rs)*"))
    (if (get-buffer vterm-buffer-name)
        (switch-to-buffer vterm-buffer-name)
      (vterm vterm-buffer-name)
      (vterm-send-string "gurk\n"))))

;; Alternative: Open Signal Desktop (GUI backup)
(defun my/signal-desktop ()
  "Launch Signal Desktop GUI application."
  (interactive)
  (start-process "signal-desktop" nil "signal-desktop")
  (message "Launched Signal Desktop"))

;; Quick send message via signal-cli (for scripting)
(defun my/signal-send-quick ()
  "Send a quick Signal message via CLI."
  (interactive)
  (my/signal-load-phone)
  (let* ((recipient (read-string "Recipient (phone or contact): "))
         (message (read-string "Message: "))
         (command (format "signal-cli -u %s send -m '%s' %s"
                         my/signal-phone
                         (replace-regexp-in-string "'" "'\\\\''" message)
                         recipient)))
    (async-shell-command command "*signal-send*")
    (message "Sending Signal message to %s..." recipient)))

;; Open gurk-rs config
(defun my/signal-config ()
  "Open gurk-rs configuration file."
  (interactive)
  (find-file "~/.config/gurk/gurk.toml"))
#+end_src

** Audio recording
#+begin_src elisp
(define-minor-mode my/audio-recorder-mode
  "Minor mode for recording audio in Emacs."
  :lighter " Audio"
  :global t
  :keymap (let ((map (make-sparse-keymap)))
            (define-key map (kbd "C-c a r") 'my/record-audio)
            (define-key map (kbd "C-c a s") 'my/stop-audio-recording)
            map))
#+end_src
** Elpher
I use elpher for gemini/gopher, and want to save bookmarks. Some quality of life enhancements.

#+begin_src elisp
(defun my/org-return-and-maybe-elpher ()
  "Handle org-return and open gemini/gopher links in elpher when appropriate."
  (interactive)
  (let ((context (org-element-context)))
    (if (and (eq (org-element-type context) 'link)
             (member (org-element-property :type context) '("gemini" "gopher")))
        ;; If it's a gemini/gopher link, open in elpher
        (let ((url (org-element-property :raw-link context)))
          (elpher-go url))
      ;; Otherwise, do the normal org-return behavior
      (org-return))))

;; Override the Return key in org-mode
(with-eval-after-load 'org
  (define-key org-mode-map (kbd "RET") 'my/org-return-and-maybe-elpher)

  ;; Register protocols with org-mode
  (org-link-set-parameters "gemini" :follow
                          (lambda (path) (elpher-go (concat "gemini://" path))))
  (org-link-set-parameters "gopher" :follow
                          (lambda (path) (elpher-go (concat "gopher://" path)))))
#+end_src

** EWW
Started using EWW to browse more often. Simple hook to make EWW full size buffer:

#+begin_src elisp
;; Remove EWW from popup rules to make it open in a full buffer
(after! eww
  (set-popup-rule! "^\\*eww\\*" :ignore t))
#+end_src

* Custom functions and templates
I have various functions in my lisp directory for creating pomodoros, refiling done tasks to my global done.org file, and adding contacts to emails in mu4e

** Functions
#+begin_src elisp
;; Universal Launcher
(load! "lisp/universal-launcher")

(load! "lisp/pomodoro")
(load! "lisp/done-refile")
(load! "lisp/meeting-assistant")
(load! "lisp/jitsi-meeting")
(load! "lisp/post-to-blog")
(load! "lisp/create-daily")
(load! "lisp/nm")
(load! "lisp/popup-dirvish-browser")
(load! "lisp/audio-record")
(load! "lisp/org-caldav")
(load! "lisp/download-media")
;; POSSE posting system
(load! "lisp/posse/posse-twitter")
(load! "lisp/gimp-tweet")

;; (load! "lisp/popup-scratch")
;; (load! "lisp/termux-sms")
;; (load! "lisp/weather")
#+end_src

* Legacy
** Email to self at beginning of day
#+begin_src elisp
;;;; Send a daily email to myself with the days agenda:
;;(defun my/send-daily-agenda ()
;;  "Send daily agenda email using mu4e"
;;  (interactive)
;;  (let* ((date-string (format-time-string "%Y-%m-%d"))
;;         (subject (format "Daily Agenda: %s" (format-time-string "%A, %B %d")))
;;         (tmp-file (make-temp-file "agenda")))
;;
;;    ;; Generate agenda and save to temp file
;;    (save-window-excursion
;;      (org-agenda nil "d")
;;      (with-current-buffer org-agenda-buffer-name
;;        (org-agenda-write tmp-file)))
;;
;;    ;; Read the agenda content
;;    (let ((agenda-content
;;           (with-temp-buffer
;;             (insert-file-contents tmp-file)
;;             (buffer-string))))
;;
;;      ;; Create and send email
;;      (with-current-buffer (mu4e-compose-new)
;;        (mu4e-compose-mode)
;;        ;; Set up headers
;;        (message-goto-to)
;;        (insert "info@thephatle.dev")
;;        (message-goto-subject)
;;        (insert subject)
;;        (message-goto-body)
;;        ;; Insert the agenda content
;;        (insert agenda-content)
;;        ;; Send
;;        (message-send-and-exit)))
;;
;;    ;; Cleanup
;;    (delete-file tmp-file)))
;;
;;;; Remove any existing timer
;;(cancel-function-timers 'my/send-daily-agenda)
;;
;;;; Schedule for 5:30 AM
;;(run-at-time "05:30" 86400 #'my/send-daily-agenda)
#+end_src

** Deft
#+begin_src elisp
;; Deft mode
;; (setq deft-extensions '("txt" "tex" "org"))
;; (setq deft-directory "~/Vaults/org/roam")
;; (setq deft-recursive t)
;; (setq deft-use-filename-as-title t)
#+end_src

** Drag and drop
#+begin_src elisp
;; Drag and drop:
;; Function for mouse events
;;(defun my/drag-file-mouse (event)
;;  "Drag current file using dragon (mouse version)"
;;  (interactive "e")
;;  (let ((file (dired-get-filename nil t)))
;;    (when file
;;      (message "Click and drag the dragon window to your target location")
;;      (start-process "dragon" nil "/usr/local/bin/dragon"
;;                     "-x"          ; Send mode
;;                     "--keep"      ; Keep the window open
;;                     file))))
;;
;;;; Function for keyboard shortcut with multiple files support
;;(defun my/drag-file-keyboard ()
;;  "Drag marked files (or current file) using dragon"
;;  (interactive)
;;  (let ((files (or (dired-get-marked-files)
;;                   (list (dired-get-filename nil t)))))
;;    (when files
;;      (message "Click and drag the dragon window to your target location")
;;      (apply 'start-process "dragon" nil "/usr/local/bin/dragon"
;;             (append (list "-x" "--keep") files)))))
;;
;;;; Bind both versions
;;(after! dired
;;  (define-key dired-mode-map [drag-mouse-1] 'my/drag-file-mouse)
;;  (define-key dired-mode-map (kbd "C-c C-d") 'my/drag-file-keyboard))
#+end_src

* TODO
- Addin video previews to dirvish
